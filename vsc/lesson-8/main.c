/*
Задача 1. Сортировка по возрастанию
Написать только одну функцию, которая сортирует массив по возрастанию.
Необходимо реализовать только одну функцию, всю программу составлять не
надо.
Строго согласно прототипу. Имя функции и все аргументы должны быть:
void sort_array(int size, int a[])
Всю программу загружать не надо, только одну эту функцию. Можно просто
закомментировать текст всей программы, кроме данной функции.
Данные на входе: Функция принимает на вход, первый аргумент - размер
массива, второй аргумент - адрес нулевого элемента.
Данные на выходе: Функция ничего не возвращает. Производит
сортировку переданного ей массива по возрастанию.
Пример №1
Данные на входе: 20 19 4 3 2 1 18 17 13 12 11 16 15 14 10 9 8 7 6 5
Данные на выходе: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
Пример №2
Данные на входе: 5 4 3 2 1
Данные на выходе: 1 2 3 4 5

-----
Задача 2. Четные в начало
Написать только одну функцию, которая ставит в начало массива все четные
элементы, а в конец – все нечетные. Не нарушайте порядок следования чисел
между собой. Строго согласно прототипу:
void sort_even_odd(int n, int a[])
Данные на входе: Функция принимает на вход целые числа
Данные на выходе: Отсортированный исходный массив
Пример №1
Данные на входе: 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1
Данные на выходе: 20 18 16 14 12 10 8 6 4 2 19 17 15 13 11 9 7 5 3

Пример №2
Данные на входе: 1 0 1 0 1
Данные на выходе: 0 0 1 1 1


-----
Задача 3. Максимум в массиве
Написать только одну функцию, которая находит максимальный элемент в
массиве. Всю программу загружать не надо.
Прототип функции: int find_max_array(int size, int a[])
Данные на входе: Массив состоящий из целых чисел. Первый аргумент,
размер массива, второй аргумент адрес нулевого элемента.
Данные на выходе: Одно целое число
Пример
Данные на входе: 773 307 371 548 531 765 402 27 573 591 217 859
662 493 173 174 125 591 324 231 130 394 573 65 570 258 343 3 586 14 785
296 140 726 598 262 807 794 510 465 66 895 182 218 302 34 205 252 687 660
952 737 2 32 310 680 36 139 346 139 489 217 767 544 158 774 883 154 802
136 569 377 867 423 224 176 118 660 513 734 45 978 983 749 909 601 270
147 433 737 789 304 842 769 815 503 190 399 3
Данные на выходе: 983

-----
Задача 4. Два одинаковых
Написать только одну логическую функцию, которая определяет, верно ли, что
среди элементов массива есть два одинаковых. Если ответ «да», функция
возвращает 1; если ответ «нет», то 0. Строго согласно прототипу:
int is_two_same(int size, int a[]);
Данные на входе: Массив из целых чисел
Данные на выходе: Функция возвращает 1 или 0
Пример №1
Данные на входе: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21
22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47
48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73
74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99
100
Данные на выходе: NO
Пример №2
Данные на входе: 1 2 1 4 5
Данные на выходе: YES

-----
Задача 5. Поменять местами
Составить функцию, которая меняет в массиве минимальный и максимальный
элемент местами. Прототип функции
void change_max_min(int size, int a[])
Данные на входе: Функция принимает на вход размер массива и
массив чисел типа int
Данные на выходе: Функция не возвращает значения, измененный
массив сохраняется на месте исходного.
Пример
Данные на входе: 1 2 3 4 5 6 7 8 9 10
Данные на выходе: 10 2 3 4 5 6 7 8 9 1

-----
Задача 6. Больше среднего
Определить количество положительных элементов квадратной матрицы,
превышающих по величине среднее арифметическое всех элементов главной
диагонали. Реализовать функцию среднее арифметическое главной
диагонали.
Данные на входе: 5 строк по 5 целых чисел через пробел
Данные на выходе: Одно целое число
Пример
Данные на входе: 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 4 4 4 4 4 5 5 5 5 5
Данные на выходе: 10

-----
Задача 7*. Клетки
Известно, что шахматная доска имеет размерность 8х8 и состоит из клеток 2х
цветов, например, черного и белого (см. рисунок). Каждая клетка имеет
координату, состоящую из буквы и цифры. Горизонтальное расположение
клетки определяется буквой от A до H, а вертикальное – цифрой от 1 до 8.
Заметим, что клетка с координатой А1 имеет черный цвет. Требуется по
заданной координате определить цвет клетки.
Данные на входе: В единственной строке входного файла записана
координата клетки на шахматной доске: всего два символа – буква и цифра
(без пробелов).
Данные на выходе: В выходной файл нужно вывести «WHITE», если
указанная клетка имеет белый цвет и «BLACK», если она черная.
Пример №1
Данные на входе: C3
Данные на выходе: BLACK
Пример №2
Данные на входе: G8
Данные на выходе: WHITE

*/

#include <stdio.h>
#include <conio.h>
#include <locale.h>
#include <string.h>
#include <ctype.h>
#include <limits.h>

// Печать массива
void printArray(int arr[], int size)
{
    for (int i = 0; i < size; i++)
    {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

// 1. Сортировка по возрастанию
// См. файл "task1_quickSort.c"
void task1()
{
}

// 2. Четные в начало
void sort_even_odd(int n, int a[])
{
    int even_count = 0;
    int odd_count = 0;
    int even[n];
    int odd[n];

    // Разделение элементов на две группы: четные и нечетные
    for (int i = 0; i < n; i++)
    {
        if (a[i] % 2 == 0)
        {
            even[even_count] = a[i];
            even_count++;
        }
        else
        {
            odd[odd_count] = a[i];
            odd_count++;
        }
    }

    // Копирование элементов из массива четных чисел в оригинальный массив
    for (int i = 0; i < even_count; i++)
    {
        a[i] = even[i];
    }

    // Копирование элементов из массива нечетных чисел в оригинальный массив
    for (int i = 0; i < odd_count; i++)
    {
        a[even_count + i] = odd[i];
    }
}

void task2()
{
    int arr[] = {20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
    int n = sizeof(arr) / sizeof(arr[0]);
    printf("Исходный массив: \n");
    printArray(arr, n);

    sort_even_odd(n, arr);

    printf("Массив после сортировки: \n");
    printArray(arr, n);
}

// 3. Максимум в массиве
int find_max_array(int size, int a[])
{
    int max = a[0]; // Предполагаем, что первый элемент максимальный

    for (int i = 1; i < size; i++)
    {
        if (a[i] > max)
        {
            max = a[i]; // Если текущий элемент больше максимального, обновляем максимальное значение
        }
    }

    return max; // Возвращаем максимальный элемент
}

void task3()
{
    int array[100] = {773, 307, 371, 548, 531, 765, 402, 27, 573, 591, 217, 859, 662, 493, 173, 174, 125, 591, 324, 231, 130, 394, 573, 65, 570, 258, 343, 3, 586, 14, 785, 296, 140, 726, 598, 262, 807, 794, 510, 465, 66, 895, 182, 218, 302, 34, 205, 252, 687, 660, 952, 737, 2, 32, 310, 680, 36, 139, 346, 139, 489, 217, 767, 544, 158, 774, 883, 154, 802, 136, 569, 377, 867, 423, 224, 176, 118, 660, 513, 734, 45, 978, 983, 749, 909, 601, 270, 147, 433, 737, 789, 304, 842, 769, 815, 503, 190, 399, 3};
    int n = 100;
    // int n = sizeof(arr) / sizeof(arr[0]);
    printf("Исходный массив: \n");
    printArray(array, n);

    int max = find_max_array(n, array);
    printf("Максимальный элемент: %d\n", max);
}

// 4. Два одинаковых.
int is_two_same(int size, int a[])
{
    for (int i = 0; i < size; i++)
    {
        for (int j = i + 1; j < size; j++)
        {
            if (a[i] == a[j])
            {
                return 1; // если найдены два одинаковых элемента, возвращаем 1
            }
        }
    }
    return 0; // если не найдены два одинаковых элемента, возвращаем 0
}

void task4()
{
    int arr1[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int size1 = sizeof(arr1) / sizeof(arr1[0]);
    printArray(arr1, size1);
    int result1 = is_two_same(size1, arr1);
    printf("Result1: %d\n", result1); // Result1: 0

    int arr2[] = {1, 2, 1, 4, 5};
    int size2 = sizeof(arr2) / sizeof(arr2[0]);
    printArray(arr2, size2);
    int result2 = is_two_same(size2, arr2);
    printf("Result2: %d\n", result2); // Result2: 1
}

// 5. Поменять местами.
void change_max_min(int size, int a[])
{
    // Поиск максимального и минимального элементов
    int max_index = 0;
    int min_index = 0;

    for (int i = 1; i < size; i++)
    {
        if (a[i] > a[max_index])
        {
            max_index = i;
        }
        if (a[i] < a[min_index])
        {
            min_index = i;
        }
    }

    // Меняем местами максимальный и минимальный элементы
    int temp = a[min_index];
    a[min_index] = a[max_index];
    a[max_index] = temp;
}

void task5()
{
    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = sizeof(arr) / sizeof(arr[0]);
    printf("Исходный массив: \n");
    printArray(arr, n);

    change_max_min(n, arr);

    printf("Массив после сортировки: \n");
    printArray(arr, n);
}

// 6. Больше среднего.
// Функция для вычисления среднего арифметического главной диагонали
float average_diagonal(int matrix[5][5])
{
    float sum = 0;
    int count = 0;

    for (int i = 0; i < 5; i++)
    {
        sum += matrix[i][i];
        count++;
    }

    return sum / count;
}

void task6()
{
    int matrix[5][5];

    // Ввод матрицы
    for (int i = 0; i < 5; i++)
    {
        for (int j = 0; j < 5; j++)
        {
            scanf("%d", &matrix[i][j]);
        }
    }

    float avg_diagonal = average_diagonal(matrix);
    int count_positive = 0;

    // Подсчет количества положительных элементов,
    // превышающих среднее арифметическое главной диагонали
    for (int i = 0; i < 5; i++)
    {
        for (int j = 0; j < 5; j++)
        {
            if (matrix[i][j] > avg_diagonal)
            {
                count_positive++;
            }
        }
    }

    printf("%d\n", count_positive);
}

// Задача 7*. Клетки
int blackOrWhite(char *str)
{
    char ch = str[0];       // получаем первый символ строки
    int num = str[1] - '0'; // получаем числовое значение второго символа строки
    // прим. -'0' нужо для того чтобы преобразовать символ в число вычитая позицию числа '0' в таблице символов.
    // Для ASCII видимо не актуально, так как чётность числа совпадает с чётностью позиции в таблице.

    // получаем значение младшего бита символа
    // прим. наверное можно пропустить и сразу сложить число и числовую позицию (к которой будут приведён символ)
    // int bit = ch & 1;

    // проверяем чётность числа
    // точно лишнее
    // int parity = num % 2 == 0 ? 0 : 1;

    // вычисляем сумму числа и чётности символа
    // int sum = bit + num; // с предварительным вычислением чётности
    int sum = ch + num; // или попробуем сразу

    // определяем значение последнего бита
    return sum & 1;
}

void task7()
{
    char str[3];
    printf("Введите строку из двух символов (буква и число): ");
    scanf("%2s", str);

    int result = blackOrWhite(str);
    printf("Result: ");
    if (result)
    {
        printf("WHITE");
    }
    else
    {
        printf("BLACK");
    }
}

void pressAnyKey()
{
    // очистка буфера ввода с помощью fflush(stdin)
    if (fflush(stdin) == EOF)
    {
        // если функция fflush(stdin) вернула ошибку, то выводим сообщение
        printf("Ошибка при очистке буфера ввода\n");
        return;
    }

    printf("\nНажмите любую клавишу для продолжения...");
    getch(); // приостановка программы
}

// MAIN
int main()
{
    setlocale(LC_ALL, "Rus");

    int choice;
    int exit = 0;

    while (!exit)
    {
        printf("\n-----------------------------\n");
        printf("1. Алгорм сортировки 'quick sort' вотдельном файле.\n");
        printf("2. Функция, которая ставит в начало массива все четные элементы, а в конец – все нечетные.\n");
        printf("3. Функция, которая находит максимальный элемент в массиве.\n");
        printf("4. Функция, которая определяет, верно ли, что среди элементов массива есть два одинаковых. \n\tЕсли ответ «да», функция возвращает 1; если ответ «нет», то 0.\n");
        printf("5. Функция, которая меняет в массиве минимальный и максимальный элемент местами.\n");
        printf("6. Определить количество положительных элементов квадратной матрицы, превышающих по величине среднее арифметическое всех элементов главной диагонали.\n");
        printf("7. Black or White.\n");

        printf("<<< Выберите пункт меню или введите иное для выхода: ");

        if (scanf("%d", &choice) != 1)
        {
            choice = -1;
        }
        printf(">>>\n");

        switch (choice)
        {
        case 1:
            break;

        case 2:
            task2();
            break;

        case 3:
            task3();
            break;

        case 4:
            task4();
            break;

        case 5:
            task5();
            break;

        case 6:
            task6();
            break;

        case 7:
            task7();
            break;

        default:
            exit = 1;
            printf("END\n");
        }

        if (exit == 1)
        {
            break;
        }
        pressAnyKey();
    }

    return 0;
}
