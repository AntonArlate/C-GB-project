// Задача 1. Сортировка по возрастанию
// Написать только одну функцию, которая сортирует массив по возрастанию.
// Необходимо реализовать только одну функцию, всю программу составлять не
// надо.
// Строго согласно прототипу. Имя функции и все аргументы должны быть:
// void sort_array(int size, int a[])
// Всю программу загружать не надо, только одну эту функцию. Можно просто
// закомментировать текст всей программы, кроме данной функции.
// Данные на входе: Функция принимает на вход, первый аргумент - размер
// массива, второй аргумент - адрес нулевого элемента.
// Данные на выходе: Функция ничего не возвращает. Производит
// сортировку переданного ей массива по возрастанию.
// Пример №1
// Данные на входе: 20 19 4 3 2 1 18 17 13 12 11 16 15 14 10 9 8 7 6 5
// Данные на выходе: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
// Пример №2
// Данные на входе: 5 4 3 2 1
// Данные на выходе: 1 2 3 4 5

#include <stdio.h>
#include <conio.h>
#include <locale.h>
#include <string.h>
#include <ctype.h>
#include <limits.h>

// Печать массива
void printArray(int arr[], int size)
{
    for (int i = 0; i < size; i++)
    {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

// Функция для обмена значениями
// тренировка применения указателей
void swap(int *a, int *b)
{
    int temp = *a; // разименовываем указытель и записываем значение
    *a = *b;       // также получаем доступ к значениям передавая из одной переменной с адресом b в значение с адресом a
    *b = temp;
}

// Функция для разделения массива и возврата индекса опорного элемента
int partition(int arr[], int low, int high)
{
    int pivot = arr[high]; // выбираем последний элемент в качестве опорного элемента
    int i = (low - 1);     // индекс меньшего элемента

    for (int j = low; j <= high - 1; j++)
    {
        // если текущий элемент меньше или равен опорному
        if (arr[j] <= pivot)
        {
            i++;
            swap(&arr[i], &arr[j]);
        }
    }
    // после прохода цикла получаем все меньше pvot слева от i остальные справа
    // теперь надо pivot поставить так чтобы он разделил массив правильно
    swap(&arr[i + 1], &arr[high]);
    return (i + 1); // возвращаем текущий индекс pivot
}

// Функция быстрой сортировки
void quickSort(int arr[], int low, int high)
{
    if (low < high) // условие выхода из рекурсии
    {
        int pi = partition(arr, low, high);

        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

// Функция входа согласно задаче
void sort_array(int size, int a[])
{
    quickSort(a, 0, size - 1);
}

// MAIN
int main()
{
    setlocale(LC_ALL, "Rus");

    int arr[] = {10, 7, 8, 9, 1, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    printf("Исходный массив: \n");
    printArray(arr, n);

    sort_array(n, arr);

    printf("Массив после сортировки: \n");
    printArray(arr, n);

    printf("---------------------\n");

    int arr2[] = {20, 19, 4, 3, 2, 1, 18, 17, 13, 12, 11, 16, 15, 14, 10, 9, 8, 7, 6, 5};
    n = sizeof(arr2) / sizeof(arr2[0]);
    printf("Исходный массив: \n");
    printArray(arr2, n);

    sort_array(n, arr2);

    printf("Массив после сортировки: \n");
    printArray(arr2, n);

    return 0;
}
